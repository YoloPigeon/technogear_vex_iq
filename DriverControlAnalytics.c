#pragma config(Sensor, port5,  gyroSensor,     sensorVexIQ_Gyro)
#pragma config(Sensor, port11, touchLED,       sensorVexIQ_LED)
#pragma config(Sensor, port12, colourSensor,   sensorVexIQ_ColorGrayscale)
#pragma config(Motor,  motor1,          leftMotor,     tmotorVexIQ, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motor2,          liftMotor2,    tmotorVexIQ, PIDControl, reversed, encoder)
#pragma config(Motor,  motor3,          liftMotor,     tmotorVexIQ, PIDControl, encoder)
#pragma config(Motor,  motor4,          HDrive,        tmotorVexIQ, PIDControl, encoder)
#pragma config(Motor,  motor6,          rightMotor,    tmotorVexIQ, PIDControl, reversed, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
/*
TECHNOGEAR DRIVER CONTROL:
*-These are pre-defined behaviors for our robot to carry out.
*-These include functions that return values or carry out tasks.
*-These have been built to be dynamic and for extensive software maintenance.

INCLUDES:
*-Functions that make use of the quadrature encoders for accurate distances.
*-Functions that make use of the colour sensor for line tracking and alignment.
*-Functions that make use of the gyro sensor for turning and straightening.
*-Functions that make use of our controller for rerun.

EXTRA INFO:
AUTHOR: Aditya Khanna, Team Technogear 21549D
VERSION: version 3.0
DATE OF CREATION: 24/2/2018
REVISION LOG:
24/2/2018- First Created.
26/2/2018- If loops replaced with switch statements, refinement.
27/2/2018- Program simplification and writeDebugStream/ displayText functions added for debugging.
2/3/2018- More commands added.
4/3/2018- Rerun added.

                            ROBOT CONFIGURATION: Technogear Technobot
    MOTORS & SENSORS:
    [I/O Port]          [Name]              [Type]                			[Location]
    Port 1        			leftMotor           VEX IQ Motor		      Left side motor
    Port 2        			leftMotor           VEX IQ Motor		      Left side motor
    Port 3       				rightMotor          VEX IQ Motor		      Right side motor (reversed)
    Port 4        			leftMotor           VEX IQ Motor		      Left side motor
    Port 6       				rightMotor          VEX IQ Motor		      Right side motor (reversed)
    port 5              gyroSensor          VEX IQ Sensor         N/A
    port 5              gyroSensor          VEX IQ Sensor         N/A
    port 5              gyroSensor          VEX IQ Sensor         N/A

*/

int threshold;//This threshold is the deadband value, i.e. if the controller is above a certain value, it will not move.
int armspeed;//Speed of the arm
int joystickValueSpacing;//This is simply how close together the values are.
int incentiveScore;//Overall score
bool broadcast_ld;
bool broadcast_a;
bool broadcast_rd;

task leftDrive()
{
	//Each task is set simultaneously, this stops the need for long programs for every single combination.
	while(true)
	{  broadcast_ld = false;
		//Reads the joy value and compares it to the threshold.
		if(abs(getJoystickValue(ChA)) > threshold && getJoystickValue(ChA) > 0)
		{
			setMotorSpeed(motor1, threshold);
		}else if(abs(getJoystickValue(ChA)) > threshold && getJoystickValue(ChD) > 0)
		{
			setMotorSpeed(motor1, -threshold);
		}else
		{

	  }
		broadcast_ld = true;
	}
}
task arm()
{
	while(true)
	{
		 broadcast_a = true;
		if(getJoystickValue(BtnRUp) == 1)
		{
			setMotorSpeed(motor2, armspeed);
			setMotorSpeed(motor3, armspeed);
		}else if(abs(getJoystickValue(ChA)) > threshold && getJoystickValue(ChD) > 0)
		{
			setMotorSpeed(motor2, -threshold);
			setMotorSpeed(motor3, -threshold);
		}
		 broadcast_a = true;
	}
}
task rightDrive()
{
	while(true)
	{
		 broadcast_rd = false;
		if(abs(getJoystickValue(ChA)) > threshold && getJoystickValue(ChA) > 0)
		{
			setMotorSpeed(motor1, threshold);
		}else if(abs(getJoystickValue(ChA)) > threshold && getJoystickValue(ChD) > 0)
		{
			setMotorSpeed(motor1, -threshold);
		}
		 broadcast_rd = true;
	}
}
bool driverLoopEnd()
{
 bool loopEnd;
 if(broadcast_ld)
 {
  loopEnd = true;


 }else
 {
  loopEnd = false;
 }
   return loopEnd;
}
task straighten()
{
	while(true)
	{
		bool straightenNeeded = abs(getMotorEncoder(motor1)) != abs(getMotorEncoder(motor6)) && abs(getJoystickValue(ChA) > 0) && getJoystickValue(ChD) > 0) ? true : false;

		if(straightenNeeded == true)
		{
			char direction = abs(getMotorEncoder(motor1)) > abs(getMotorEncoder(motor6)) ? 'L' : 'R'
			if(direction = 'R')
			{
				while(getGyroDegrees(port5) != 0)
				{
					setMotorSpeed(motor1, 100);
					setMotorSpeed(motor6, -100);
				}
			}else
			{
				while(getGyroDegrees(port5) != 0)
				{
					setMotorSpeed(motor1, -100);
					setMotorSpeed(motor6, 100);
				}
			}
		}
	}
}
//This is a fairly complex, however clean and well documented data analysis program.
//This program allows the user to set 'trends' or good driving pracitices.
//It uses a contextual algorithm to use these 'trends' to predict which one of them to use in a certain situation.
bool trendCheck(bool mtr1, bool mtr2, bool mtr3, bool mtr4, bool mtr6)
{
	//This comparitively simple algorithm checks whether the trends match with the previous bool values.
	bool mtrTrend1;
	bool mtrTrend2;
	bool mtrTrend3;
	bool mtrTrend4;
	bool mtrTrend6;
	bool mtrTrend;
	//These denote the various motors.
	if(mtr1 == getMotorMoving(motor1))
	{
		mtrTrend1 = true;
	}else
	{
		mtrTrend1 = false;
	}
	if(mtr2 == getMotorMoving(motor2))
	{
		mtrTrend2 = true;
	}else
	{
		mtrTrend2 = false;
	}
	if(mtr3 == getMotorMoving(motor3))
	{
		mtrTrend3 = true;
	}else
	{
		mtrTrend3 = false;
	}
	if(mtrTrend1 && mtrTrend2 && mtrTrend3 && mtrTrend4 && mtrTrend6)
	{
		mtrTrend = true;
	}else
	{
		mtrTrend = false;
	}
}
//This is a simple algorithm, it is part of a much more complex one however.
void motorTrendChange(mtr1Prev, mtr2Prev, mtr3Prev, mtr4Prev, mtr6Prev)
{
  //This program simply waits for the motors to change in trend.
	waitUntil(mtr1Prev != getMotorMoving(motor1) || mtr1Prev != getMotorMoving(motor1) ||mtr1Prev != getMotorMoving(motor1) ||mtr1Prev != getMotorMoving(motor1))
	//Now it has to take into account that the change may not happen at
 }

void trendSet(bool mtr1Prev, bool mtr2Prev, bool mtr3Prev, bool mtr4Prev, bool mtr6Prev, bool mtr1, bool mtr2, bool mtr3, bool mtr4, bool mtr6)
{
 trendCheck(mtr1Prev, mtr2Prev, mtr3Prev, mtr4Prev, mtr6Prev)
 if(mtrTrend == true)
 {
  motorTrendChange();
  trendCheck(mtr1, mtr2, mtr3, mtr4, mtr6);
  if(mtrTrend == true)
  {

  }
 }
}
task analytics()

{
	int prevVal1;
	int prevVal2;
	int prevVal3;
	while(true)
	{
		datalogDataGroupStart();

		datalogAddValue(getMotorSpeed(motor1));
		if(prevVal3 > prevVal2 && prevVal2 > prevVal1)
		{
			writeDebugStream("rising\n");


		}else if (prevVal3 < prevVal2 < prevVal1)
		{
			writeDebugStream("going down\n"
		}



	}
}
task main()
{
 //The main task simply starts off the
 startTask(leftDrive);
 startTask(arm);
 startTask(rightDrive);
 startTask(analytics);
 startTask(straighten);


}
